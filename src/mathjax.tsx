"use client"

import React, { ComponentPropsWithoutRef, useEffect, useLayoutEffect, useRef, useState } from "react"
import { useMathJax } from "./context"
import type { MathJaxOverrideableProps } from "./types"

export interface MathJaxProps extends MathJaxOverrideableProps {
  inline?: boolean
  onInitTypeset?: () => void
  onTypeset?: () => void
  text?: string
  dynamic?: boolean
  children?: React.ReactNode
  suppressHydrationWarning?: boolean
  clientOnly?: boolean
}

const typesettingFailed = (err: any) =>
  `Typesetting failed: ${typeof err.message !== "undefined" ? err.message : JSON.stringify(err)}`

export function MathJax({
  inline = false,
  hideUntilTypeset,
  onInitTypeset,
  onTypeset,
  text,
  dynamic,
  typesettingOptions,
  renderMode,
  children,
  suppressHydrationWarning = true,
  clientOnly = false,
  ...rest
}: MathJaxProps & ComponentPropsWithoutRef<"span">) {
  const [isClient, setIsClient] = useState(false)
  const [isHydrated, setIsHydrated] = useState(false)

  // in render mode "pre", this keeps track of the last value on text to determine when we need to run typesetting
  const lastChildren = useRef<string>("")

  /* the parent of all MathJax content, in render mode "pre" the content generated by MathJax is added to this node
  after rendering whereas in render mode "post", the content of this node is processed by MathJax after rendering */
  const ref = useRef<HTMLElement>(null)

  const mjPromise = useMathJax()

  // allow context values to steer this component for some props if they are undefined
  const usedHideUntilTypeset = hideUntilTypeset ?? mjPromise?.hideUntilTypeset
  const usedRenderMode = renderMode ?? mjPromise?.renderMode
  const usedConversionOptions = typesettingOptions ?? mjPromise?.typesettingOptions
  const usedDynamic = dynamic === false ? false : (dynamic || process.env.NODE_ENV !== "production")

  // whether initial typesetting of this element has been done or not
  const initLoad = useRef(false)

  // mutex to signal when typesetting is ongoing (without it we may have race conditions)
  const typesetting = useRef(false)

  // Check if we're on client side
  useEffect(() => {
    setIsClient(true)
  }, [])

  // Mark as hydrated after first render
  useEffect(() => {
    setIsHydrated(true)
  }, [])

  // handler for initial loading
  const checkInitLoad = () => {
    if (!initLoad.current) {
      if (usedHideUntilTypeset === "first" && ref.current !== null) {
        ref.current.style.visibility = "visible"
      }
      if (onInitTypeset) onInitTypeset()
      initLoad.current = true
    }
  }

  // callback for when typesetting is done
  const onTypesetDone = () => {
    if (usedHideUntilTypeset === "every" && usedDynamic && usedRenderMode === "post" && ref.current !== null) {
      ref.current.style.visibility = rest.style?.visibility ?? "visible"
    }
    checkInitLoad()
    if (onTypeset) onTypeset()
    typesetting.current = false
  }

  // validator for text input with renderMode = "pre"
  const validText = (inputText?: string) => typeof inputText === "string" && inputText.length > 0

  // guard which resets the visibility to hidden when hiding the content between every typesetting
  if (
    !typesetting.current &&
    ref.current !== null &&
    usedDynamic &&
    usedHideUntilTypeset === "every" &&
    usedRenderMode === "post"
  ) {
    ref.current.style.visibility = "hidden"
  }

  // If clientOnly and not on client, render placeholder
  if (clientOnly && !isClient) {
    return (
      <span
        {...rest}
        style={{
          display: inline ? "inline" : "block",
          ...rest.style,
          visibility: "hidden"
        }}
        ref={ref}
      >
        {children}
      </span>
    )
  }

  /**
   * Effect for typesetting, important that this does not trigger a new render and runs as seldom as possible (only
   * when needed). It is good that it is in an effect because then we are sure that the DOM to be is ready and
   * thus, we don't have to use a custom timeout to accommodate for this. Layout effects runs on the DOM to be before
   * the browser has a chance to paint. Thereby, we reduce the chance of ugly flashes of non-typeset content.
   *
   * Note: useLayoutEffect causes an ugly warning in the server console with SSR so we make sure to use useEffect if
   * we are in the backend instead. Neither of them run in the backend so no extra care needs to be taken of the
   * Promise.reject() passed from context (which happens on SSR) on server.
   */
  const effectToUse = typeof window !== "undefined" ? useLayoutEffect : useEffect
  effectToUse(() => {
    // Only run typesetting on client side and after hydration
    if (!isClient || !isHydrated) return

    if (usedDynamic || !initLoad.current) {
      if (ref.current !== null) {
        if (mjPromise) {
          if (usedRenderMode === "pre") {
            if (!validText(text))
              throw Error(
                `Render mode 'pre' requires text prop to be set and non-empty, which was currently "${text}"`
              )
            if (!typesettingOptions || !typesettingOptions.fn)
              throw Error(
                "Render mode 'pre' requires 'typesettingOptions' prop with 'fn' property to be set on MathJax element or in the MathJaxContext"
              )
          }
          if (usedRenderMode === "post" || text !== lastChildren.current) {
            if (!typesetting.current) {
              typesetting.current = true
              mjPromise.promise
                .then((mathJax) => {
                  if (usedRenderMode === "pre") {
                    if (typesettingOptions!.fn.endsWith("Promise"))
                      mathJax.startup.promise
                        .then(() =>
                          mathJax[usedConversionOptions!.fn](text!, {
                            ...(usedConversionOptions?.options || {}),
                            display: !inline
                          })
                        )
                        .then((output) => {
                          if (typeof output === 'string') {
                            // Handle string output (for mml functions)
                            if (ref.current !== null) ref.current.innerHTML = output
                            onTypesetDone()
                          } else {
                            // Handle HTMLElement output
                            lastChildren.current = text!
                            mathJax.startup.document.clear()
                            mathJax.startup.document.updateDocument()
                            if (ref.current !== null) ref.current.innerHTML = output.outerHTML
                            onTypesetDone()
                          }
                        })
                        .catch((err) => {
                          onTypesetDone()
                          throw Error(typesettingFailed(err))
                        })
                    else
                      mathJax.startup.promise
                        .then(() => {
                          const output = mathJax[usedConversionOptions!.fn](text!, {
                            ...(usedConversionOptions?.options || {}),
                            display: !inline
                          })
                          return Promise.resolve(output)
                        })
                        .then((output) => {
                          if (typeof output === 'string') {
                            // Handle string output (for mml functions)
                            if (ref.current !== null) ref.current.innerHTML = output
                            onTypesetDone()
                          } else {
                            // Handle HTMLElement output
                            lastChildren.current = text!
                            mathJax.startup.document.clear()
                            mathJax.startup.document.updateDocument()
                            if (ref.current !== null) ref.current.innerHTML = output.outerHTML
                            onTypesetDone()
                          }
                        })
                        .catch((err) => {
                          onTypesetDone()
                          throw Error(typesettingFailed(err))
                        })
                  } else {
                    // renderMode "post"
                    mathJax.startup.promise
                      .then(() => {
                        if (ref.current) {
                          mathJax.typesetClear([ref.current])
                          return mathJax.typesetPromise([ref.current])
                        }
                        return Promise.resolve()
                      })
                      .then(onTypesetDone)
                      .catch((err) => {
                        onTypesetDone()
                        throw Error(typesettingFailed(err))
                      })
                  }
                })
                .catch((err) => {
                  onTypesetDone()
                  throw Error(typesettingFailed(err))
                })
            }
          }
        } else
          throw Error(
            "MathJax was not loaded, did you use the MathJax component outside of a MathJaxProvider?"
          )
      }
    }
  })

  return (
    <span
      {...rest}
      suppressHydrationWarning={suppressHydrationWarning}
      style={{
        display: inline ? "inline" : "block",
        ...rest.style,
        visibility: usedHideUntilTypeset ? "hidden" : rest.style?.visibility
      }}
      ref={ref}
    >
      {children}
    </span>
  )
} 